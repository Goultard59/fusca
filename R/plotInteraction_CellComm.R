#' Plot inferred cell-cell interaction network.
#'
#' Plot the heatmap of the inferred cell-cell interaction network and return it.
#' The interaction data frame has cells of the first type as rows and cells of
#' the second type as columns, the values are the number of unique interactions
#' between the cell type pairs.
#'
#' @param graph list; the graph and the pairs as generated by the cellnetwork3
#' function.
#'
#' @return list; the data frame which the rows are the cells of first type,
#' while the columns are the cells of the second type, and the plot. The values
#' of the data frame are the number of unique interactions between the pairs.
#'
#' @export
plotInteractionMatrix2 <- function(graph){
  edges <- graph$pairs
  edges <- dplyr::bind_rows(edges)
  #
  # duvida: por que nÃ£o usa a interactionmatrix?
  #
  df <- data.frame(matrix(0, nrow = length(unique(edges$celltype1)),
                          ncol = length(unique(edges$celltype2))))
  rownames(df) <- unique(as.vector(edges$celltype1))
  colnames(df) <- unique(as.vector(edges$celltype2))
  aux <- list()
  for(cell1 in rownames(df)){
    for(cell2 in colnames(df)){
      c <- edges[which(edges$celltype1 == cell1 & edges$celltype2 == cell2),]
      df[cell1, cell2] <- length(unique(c$pair))
    }
  }
  g <- pheatmap::pheatmap(df, border_color='white', clustering_method = 'ward.D',
                     cutree_rows = 3, cutree_cols = 3, silent = T)
  return(list(df = df, plot = g))
}

#' Plot graph of interactions.
#'
#' Create a plot from the graph of interactions and save it to file.
#'
#' @param matrix data frame; the interaction matrix as calculated by the
#' interactionmatrix function.
#' @param interactionList character vector; the list of types considered in the
#' interactions.
#' @param interactionTable matrix?; the interactions for each pair, plus the
#' pvalue column, as calculated bu the calculatePvalue function.
#'
#' @return list; the igraph interaction network and the plot.
#'
#' @export
plotInteractionNetwork <- function(matrix, interactionList, interactionTable){
  matrix <- matrix[ , interactionList]
  matrix$pair <- rownames(matrix)
  matrix.m <- reshape2::melt(matrix, id.vars = c('pair'))
  colnames(matrix.m) <- c('from', 'to', 'weight')
  matrix.m <- matrix.m[which(matrix.m$weight > 0),]
  x <- interactionTable[interactionTable$celltypes %in% interactionList,]
  graph <- igraph::graph.data.frame(matrix.m, directed = FALSE)
  igraph::V(graph)$label <- igraph::V(graph)$name
  igraph::V(graph)$type <- ""
  igraph::V(graph)[igraph::V(graph)$name %in% rownames(matrix)]$type <-
    'Ligand-Receptor'
  igraph::V(graph)[igraph::V(graph)$name %in% colnames(matrix)]$type <-
    'Cell-Cell'
  igraph::V(graph)$size <- 1
  igraph::V(graph)[as.vector(x$pair)]$size <- as.vector(x$mean)
  igraph::V(graph)$label = igraph::V(graph)$name
  g <- ggplot2::fortify(graph)
  g$type <- factor(g$type, levels=c('Ligand-Receptor','Cell-Cell'))
  #
  # duvida: esse seed precisa?
  #
  set.seed(3)
  p <- ggplot2::ggplot(data = g, ggplot2::aes(from_id = from, to_id = to),
                       pch=21, colour='black') +
    geomnet::geom_net(ggplot2::aes(colour=size, label=label, size=size,
                                   shape=type), layout.alg = "kamadakawai",
             labelon = FALSE, vjust = -0.6, ecolour = "lightgrey",
             directed =FALSE, fontsize = 3, ealpha = 0.2, labelcolour = 'black',
             fiteach=T, arrowsize = 1, repel=TRUE) +
    geomnet::theme_net() + ggplot2::theme(legend.position = "bottom") +
    ggplot2::scale_colour_gradientn("", colours = c('white', 'red')) +
    #scale_colour_brewer("", palette = 'Set1') +
    ggplot2::theme(panel.border = ggplot2::element_rect(fill = NA,
                                                        colour = "black"))
  return(list(graph = graph, plot = p))
}
